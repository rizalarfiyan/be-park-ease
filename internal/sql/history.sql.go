// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: history.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllHistory = `-- name: CountAllHistory :one
select COUNT(*) from entry_history eh
LEFT JOIN exit_history exh on eh.id = exh.entry_history_id
LEFT JOIN fine_history fh on eh.id = fh.entry_history_id
`

func (q *Queries) CountAllHistory(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllHistory)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEntryHistory = `-- name: CreateEntryHistory :exec
INSERT INTO entry_history (id, location_code, vehicle_type_code, vehicle_number, created_by)
VALUES ($1, $2, $3, $4, $5)
`

type CreateEntryHistoryParams struct {
	ID              interface{}
	LocationCode    string
	VehicleTypeCode string
	VehicleNumber   string
	CreatedBy       int32
}

func (q *Queries) CreateEntryHistory(ctx context.Context, arg CreateEntryHistoryParams) error {
	_, err := q.db.Exec(ctx, createEntryHistory,
		arg.ID,
		arg.LocationCode,
		arg.VehicleTypeCode,
		arg.VehicleNumber,
		arg.CreatedBy,
	)
	return err
}

const createExitHistory = `-- name: CreateExitHistory :exec
INSERT INTO exit_history (entry_history_id, location_code, price, exited_by)
VALUES ($1, $2, $3, $4)
`

type CreateExitHistoryParams struct {
	EntryHistoryID string
	LocationCode   string
	Price          pgtype.Numeric
	ExitedBy       int32
}

func (q *Queries) CreateExitHistory(ctx context.Context, arg CreateExitHistoryParams) error {
	_, err := q.db.Exec(ctx, createExitHistory,
		arg.EntryHistoryID,
		arg.LocationCode,
		arg.Price,
		arg.ExitedBy,
	)
	return err
}

const createFineHistory = `-- name: CreateFineHistory :exec
INSERT INTO fine_history (entry_history_id, location_code, price, identity, vehicle_identity, name, address, description, fined_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateFineHistoryParams struct {
	EntryHistoryID  string
	LocationCode    string
	Price           pgtype.Numeric
	Identity        string
	VehicleIdentity string
	Name            string
	Address         string
	Description     string
	FinedBy         int32
}

func (q *Queries) CreateFineHistory(ctx context.Context, arg CreateFineHistoryParams) error {
	_, err := q.db.Exec(ctx, createFineHistory,
		arg.EntryHistoryID,
		arg.LocationCode,
		arg.Price,
		arg.Identity,
		arg.VehicleIdentity,
		arg.Name,
		arg.Address,
		arg.Description,
		arg.FinedBy,
	)
	return err
}

const getAllHistory = `-- name: GetAllHistory :many
select CAST(eh.id as varchar) as id, eh.location_code, eh.vehicle_type_code, eh.vehicle_number, coalesce(fh.fined_at, coalesce(exh.exited_at, eh.created_at)) date,
       CASE WHEN fh.fined_at IS NOT NULL THEN 'fine' WHEN exh.exited_at IS NOT NULL THEN 'exit' ELSE 'entry' END AS type
from entry_history eh
LEFT JOIN exit_history exh on eh.id = exh.entry_history_id
LEFT JOIN fine_history fh on eh.id = fh.entry_history_id
`

type GetAllHistoryRow struct {
	ID              string
	LocationCode    string
	VehicleTypeCode string
	VehicleNumber   string
	Date            pgtype.Timestamp
	Type            string
}

func (q *Queries) GetAllHistory(ctx context.Context) ([]GetAllHistoryRow, error) {
	rows, err := q.db.Query(ctx, getAllHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllHistoryRow{}
	for rows.Next() {
		var i GetAllHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.LocationCode,
			&i.VehicleTypeCode,
			&i.VehicleNumber,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastHistoryByVehicleNumber = `-- name: GetLastHistoryByVehicleNumber :one
select eh.vehicle_number, coalesce(fh.fined_at, coalesce(exh.exited_at, eh.created_at)) date,
       CASE WHEN fh.fined_at IS NOT NULL THEN 'fine' WHEN exh.exited_at IS NOT NULL THEN 'exit' ELSE 'entry' END AS type
from entry_history eh
LEFT JOIN exit_history exh on eh.id = exh.entry_history_id
LEFT JOIN fine_history fh on eh.id = fh.entry_history_id
WHERE eh.vehicle_number = $1
ORDER BY date DESC
LIMIT 1
`

type GetLastHistoryByVehicleNumberRow struct {
	VehicleNumber string
	Date          pgtype.Timestamp
	Type          string
}

func (q *Queries) GetLastHistoryByVehicleNumber(ctx context.Context, vehicleNumber string) (GetLastHistoryByVehicleNumberRow, error) {
	row := q.db.QueryRow(ctx, getLastHistoryByVehicleNumber, vehicleNumber)
	var i GetLastHistoryByVehicleNumberRow
	err := row.Scan(&i.VehicleNumber, &i.Date, &i.Type)
	return i, err
}

const getLastHistoryWithPriceByVehicleNumber = `-- name: GetLastHistoryWithPriceByVehicleNumber :one
select eh.vehicle_number, vt.price, coalesce(fh.fined_at, coalesce(exh.exited_at, eh.created_at)) date,
       CASE WHEN fh.fined_at IS NOT NULL THEN 'fine' WHEN exh.exited_at IS NOT NULL THEN 'exit' ELSE 'entry' END AS type
from entry_history eh
LEFT JOIN exit_history exh on eh.id = exh.entry_history_id
LEFT JOIN fine_history fh on eh.id = fh.entry_history_id
JOIN vehicle_type vt on eh.vehicle_type_code = vt.code
WHERE eh.vehicle_number = $1
ORDER BY date DESC
LIMIT 1
`

type GetLastHistoryWithPriceByVehicleNumberRow struct {
	VehicleNumber string
	Price         pgtype.Numeric
	Date          pgtype.Timestamp
	Type          string
}

func (q *Queries) GetLastHistoryWithPriceByVehicleNumber(ctx context.Context, vehicleNumber string) (GetLastHistoryWithPriceByVehicleNumberRow, error) {
	row := q.db.QueryRow(ctx, getLastHistoryWithPriceByVehicleNumber, vehicleNumber)
	var i GetLastHistoryWithPriceByVehicleNumberRow
	err := row.Scan(
		&i.VehicleNumber,
		&i.Price,
		&i.Date,
		&i.Type,
	)
	return i, err
}
